### Chapter 01

1. With respect to the term software crisis, the textbook list four concerns or components. List the four perceived components of this software crisis.
Delivery of software:
1) on time
2) within budget
3) fault free
4) meeting the client's needs

2. Assume that the terms software life-cycle and software development cycle refer to two completely different kinds of things. How would you describe the differences between the two? This should require research beyond the discussion in the text.
The term software life-cycle deals with a large portion of the life of the software post-delivery
including the retirement of the software.
The term software development generally only deals with the actual details of the creation and maintenance of the lasting product before delivery to the client.

3. Give a detailed account of the practice of perfective maintenance. Give a detailed account of the practice of adaptive maintenance. “Detailed account” requires a narrative in sufficient detail to illustrate the differences between these two types of maintenance. You may use hypothetical accounts, accounts from the text, or accounts based on your experience.
An example of perfective maintenance could be in an environment where multiple users need to access a website. The process of loading that website from the server it is hosted most likely initially occurred on a first in first out basis. However, in order to streamline the large amounts of people accessing different sites and the like on the servers to make response times faster, the addition of a prioritized queue based on the frequency of hits on a website in order to speed up the process of accessing heavily trafficked sites would be an example of perfective maintenance.
Adaptive maintenance in the same situation would be the implementation of modifying already existing code for the introduction to more advanced hardware micromanagement of the processes underlying accessing sites on the server based on the hardware that might be used.

4. Explain: “The difference between hardware and software is that, as hardware ages it breaks more
and more and eventually has to be thrown away, while software as it ages gets better and better and
eventually achieves correctness.”
I would explain this quote by pointing out the difference inherent in the mutability of software versus hardware. The names also lend to the implication of the inherent difference in mutability. Software is written lines of information inside of a computer that is stored and executed. Where as hardware is the physical equipment consisting of electronics and physical components coming together to be something that is functional. Software's readiness to be modified and changed lends to the process of improving it till it achieves it's purpose which might be constantly shifting to be a better product through different maintenance techniques. Hardware once it is built and completed is a finished product which will eventually break down to it existing solely in the physical world to be used for it's initial purpose. 

5. According to the text, the cost of correcting software faults prior to implementation is a fraction of
the cost of correcting software faults subsequent to implementation. Also according to the text, the
number of faults detected subsequent to implementation is a fraction of the number of faults detected
prior to implementation. What does this say to you?
Following simple cost efficiency principles in the market, this trend in software engineering would imply that vigorous testing, quality assurance, and management often lends to cost effective implementation and maintenance. This could imply that distribution of the fixes for faults found after implementation are expensive due to distribution issues and the risk of faulty products being sold to clients and the weight of that on a company's or developer's reputation of quality.

6. The book notes that, in software engineering, there are no separate planning, testing, or documentation
phases. This tells you something very significant about the practice of software engineering. What
does this tell you? Don’t be quick to answer this question. In one important sense, this entire course
depends on your answer to this question.
The fact that there is no definitive phases that are solely planning, testing, and documentation implies that throughout the development and life cycles that they should be constantly being monitored and implemented through the cycles.

7. Defend this statement: structured programming techniques form an essential part of object oriented
programming techniques. Note that the text does not argue that object oriented programming has
completely replaced structured programming.
Object oriented programming techniques in implementation breaks down parts of an overall software product into somewhat more tangible modules that structured programming techniques can be applied to in smaller and easier to handle parts that normally wouldn't be. Not doing so results in huge technical difficulties for larger software products, thus allowing for the object oriented programming techniques to make use of the efficiency of the structured programming techniques on larger projects. Doing so after breaking down a project into different objects allows for different teams and software designers to work on the same project with streamlined reasons for communication and constant planning to develop different parts or objects of the software that might interact with each other. This streamlines the process of developing and maintaining larger projects by increasing independence of the different modules, allowing for and promoting code reuse, and if done correctly, makes code and the software easier to understand and bring other developers on board as needed.

8. In designing a piece of software, is it more important for the developer to frequently interact with the
client or with the users? Why or why not?
The majority of the time I would say that the frequent interactions with a client are more important than users in the designing process. I say majority because of the different types of products that could be developed, where the client is funding the project due to it being their idea and it fulfills the purpose they wanted it to fulfill. However, products that are made to be used by users that are not just the client could lend weight to the need for interaction with users as well in order to compromise between user and client wants or needs. If you are lucky, you may have a client who wants the product to be user need driven. Ultimately though, the client is the end all be all since you are being paid by them to implement what they want.

9. Point 8 of the Software Code of Ethics cited in the text states in part: “Software engineers shall
participate in lifelong learning regarding the practice of their profession . . . ”. Identify one activity
that you could engage in on a weekly, monthly, quarterly, or yearly basis, for the remainder of your
life, that would promote this kind of learning.
On a monthly basis I would encourage, and already participate in, to search and read up on different topics that are relevant to software engineering as a field. This could range from new and industry influencing products, techniques, and languages, as well as older ones that may have been passed up on as old and outdated to give yourself new perspectives and knowledge to increase your understanding of where the industry is going or might be going. This also involves possible socio-political-economic factors that could influence the industry.

10. Read “The Cathedral and the Bazaar” by Eric Steven Raymond in the pdf directory. Write a one
paragraph appreciation of this essay. (A paragraph consists of multiple sentences, perhaps between
five and ten.)
Reading the article, I noted that the way Raymond found and tried to test the Bazaar method of development was an interesting use of development being driven by the users that would end up using the software. This lent the idea to me that perhaps the Bazaar method is a very good method to approach development of a software that would be a useful tool to users that have a higher level of technical expertise but also have a need for the purpose that the software is supposed to fulfill. This also allows for ease of maintenance and development of the software by the users for the users. As stated in the essay, this contributed to a sense of community and being able to be a part of something and developing something that has use for themselves and many others like them. The essay also made good points of the faults of the Cathedral. Whether or not one can exist and replace the other is however not addressed to my recollection, nor do I myself think one can replace the other due to the nature that is an industry in a capitalist economy. 