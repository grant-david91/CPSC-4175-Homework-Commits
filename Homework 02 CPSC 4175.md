# CPSC 4175 HW 02

## 1. What is the first step in creating a piece of software?
The first step in creating a piece of software is to determine what the client needs. This is an important distinction from what the client wants.

## 2. What is the difference in discovering what the client needs and discovering what the software should do?
A client may be able to vocalize what they need but not quite understand what that entails in a piece of software or if the software is even needed instead of possibly modifying or addressing a different problem that could exist in their business model, existing software, or organizational issues with the two interacting, as well as if that may be an issue that will persist even after the software is developed.

## 3. In what sense is a software engineer a generalist rather than a specialist?
A software engineer is a generalist more so due to the fact that their skills must cover a large portion of different specialties rather than just coding, despite what most non computer science industry involved professionals would like to think. These skills range from management, logic and algorithmic capabilities, business acumen, to being capable of critical thinking skills to understanding ethical issues that may arise in the industry.

## 4. List some techniques the book identifies as useful for determining requirements, and for each, give one reason why that technique might not be effective.
### 1. Interviewing
*  Might not be effective when dealing with an application domain where the interviewer is not fully familiar.

### 2. Questionnaire
*  Might not be effective due to the fact that it doesn't provide open ended questions that the answer can be used to further elaborate and get more information from.

### 3. Business Forms
*  Might not be effective when used by itself since the forms are capable of really just clarifying the needs of a client rather than determining them.

### 4. Direct Observation
*  Might not be effective when considering the time investment needed to actually go over tapes or dedicated to actually observing business practices.

## 5. In what sense are requirements dynamic rather than static?
Requirements should be considered dynamic rather than static since the requirements are often subject to change during the requirements workflow. This can be caused by negotiation, developer decisions, as well as client demands. The point is to get the requirements scaled down to what the client wants while factoring in any kind of cost-to-benefit for any requirements that may change during the process.

## 6. In your own words, state the difference between functional and nonfunctional requirements. 
Functional requirements seem to be the actual required operations and features that a software needs to be able to complete in order to even begin to meet the client's needs. Non-functional requirements usually are the requirements that the client may want or would benefit from easing the process of using the software or making it more capable of filling the purpose of the software.

### Do you think that there is any such thing as a "nonfunctional” requirement?
Yes, but not in the sense that takes "nonfunctional" literally. As a software engineer one should strive to make the best experience possible for the users of a software being developed. However, due to how business is conducted sometimes the best experience possible is not fully reachable due to time and budget constraints.

## 7. What is top-down analysis? You may also see this referred to as structured analysis.
Top-down analysis, or structured analysis, is an approach at tackling a problem domain in a way that allows for taking what the end result software is needed to be capable of doing and breaking it down to smaller components without necessarily detailing the actual design or finer requirements of the smaller components in order to fill their functions.

###  How is this different than the case study in chapter 11 in the book?
This seems different from the case study in the book because the board of trustees specifically hired a software design firm for a pilot project in order to computerize a small portion of their business work flow. It seems the approach was actually done in a fashion that seems to resemble the opposite approach, or a bottom-up design flow.

## 8. Prototyping is a very controversial issue. Can you think of some reasons why many software engineers think that prototyping is harmful?
Software engineers may be of the mind that prototyping may be harmful due to the fact that a good rapid prototype may give the client's a false sense of comfort or expectation that the developers should be able to quickly and thoroughly build their product and all the requirements and specifications that the prototype may lack on a much more accelerated timeline than what is possible for the project.

## 9. Teams One and Two both have the responsibility for developing a software requirements specification for a project. Team One has infrequent changes to its requirements specification, while Team Two has very frequent changes to its requirements specification. Which team is doing the better job? Justify your answer.
In this scenario it is difficult to determine which team is doing a better job because we don't know how close each of the stages of the software requirements specification process is getting to what the actual client needs. Assuming that the initial start of this process each team are evenly skilled at eliciting the requirements from the client, and each team incrementally gets closer to the end needs of the client evenly for each change, then Team Two is doing the better job. Of course for other controlled variables and situations this could be not true.

## 10. More software defects are traceable to bad requirements analysis than to any other source. Why do you think this is true?
Bad requirements analysis may be responsible for many different issues that will arise during the process of actually developing a software. These can range from inaccuracies in pulling inputs for the software to operate or even producing a result or output that is wholly incorrect because of not getting the correct information from the client of what is actually needed to be done in the problem domain.